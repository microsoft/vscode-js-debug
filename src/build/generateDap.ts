/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/

import got from 'got';
import { JSONSchema4 } from 'json-schema';
import custom from './dapCustom';
import { autoGeneratedFileHeader, writeCodeToFile } from './generateUtils';

/* eslint-disable @typescript-eslint/no-non-null-assertion */

function toTitleCase(s: string) {
  return s[0].toUpperCase() + s.substr(1);
}

function hasRef(definition: JSONSchema4): definition is JSONSchema4 & { $ref: JSONSchema4 } {
  return typeof definition === 'object' && !!definition.$ref;
}

async function generate() {
  const { body: standard } = await got<JSONSchema4>(
    'https://raw.githubusercontent.com/microsoft/debug-adapter-protocol/main/debugAdapterProtocol.json',
    { responseType: 'json' },
  );
  const result: string[] = [];

  result.push(autoGeneratedFileHeader('generateDap.js'));
  result.push(`import * as E from './error';`);
  result.push(``);
  result.push(`export namespace Dap {`);
  result.push(`export type Error = E.Error;`);
  result.push(`export type Message = E.Message;`);
  result.push(`export type integer = number;`);
  result.push(``);

  function appendText(text?: string) {
    if (!text) return;
    result.push(`/**`);
    for (const line of text.split('\n')) result.push(` * ${line}`);
    result.push(` */`);
  }

  function createSeparator() {
    let first = true;
    return function () {
      if (!first) result.push(``);
      first = false;
    };
  }

  const defs = { ...standard.definitions, ...custom.definitions };

  function definition(name: string) {
    return name.substring('#/definitions/'.length);
  }

  const types: string[] = [];
  const typesSet = new Set<string>();

  function generateType(prop: JSONSchema4): string {
    const valueEnum = (prop as unknown as { _enum?: string[] })._enum;
    if (valueEnum) {
      return `${valueEnum.map(value => `'${value}'`).join(' | ')}`;
    }

    if (prop['$ref']) {
      const def = definition(prop['$ref']);
      if (!typesSet.has(def)) {
        types.push(def);
        typesSet.add(def);
      }
      return `${def}`;
    }

    if (Array.isArray(prop.type)) {
      return `${prop.type.map(type => generateType({ type })).join(' | ')}`;
    }

    if (prop.type === 'array') {
      const subtype = prop.items ? generateType(prop.items as JSONSchema4) : 'any';
      return `(${subtype})[]`;
    }

    if (prop.oneOf) {
      return `${prop.oneOf.map(generateType).join(' | ')}`;
    }

    if (!prop.type) {
      throw new Error(`Expected prop type in ${JSON.stringify(prop)}`);
    }

    return prop.type;
  }

  function appendProps(
    props: { [k: string]: JSONSchema4 },
    required?: Iterable<string> | true | false | null,
  ) {
    const requiredSet = required === true ? new Set(Object.keys(props)) : new Set(required || []);
    const propSeparator = createSeparator();
    for (const name in props) {
      const prop = props[name];
      propSeparator();
      appendText(prop.description);
      const generatedType = generateType(prop);
      result.push(`${name}${requiredSet.has(name) ? '' : '?'}: ${generatedType};`);
    }
  }

  function getExtends(def: JSONSchema4) {
    const refs = def
      .allOf!.filter(hasRef)
      .map(x => definition(x.$ref))
      .join(', ');

    return 'extends ' + refs;
  }

  const stubs: { type: string; name: string; value: JSONSchema4 }[] = [];
  const interfaceSeparator = createSeparator();

  interfaceSeparator();

  const apiSeparator = createSeparator();

  // ============================ API ==============================

  result.push(`export interface Api {`);
  for (const name in defs) {
    const def = defs[name];
    if (!def.allOf) {
      continue;
    }
    const ref = def.allOf.find(hasRef);
    const desc = def.allOf.find(parent => !hasRef(parent)) as JSONSchema4 | undefined;
    if (!ref || !desc) {
      continue;
    }

    if (ref.$ref === '#/definitions/Event') {
      apiSeparator();
      appendText(desc.description);
      result.push(`${desc.properties!.event.enum![0]}(params: ${name}Params): void;`);
      stubs.push({
        type: 'event',
        name: `${name}Params`,
        value: desc.properties?.body || { properties: {} },
      });
    }
    if (ref['$ref'] === '#/definitions/Request') {
      const short = desc.properties!.command.enum![0];
      const title = toTitleCase(String(short));
      apiSeparator();
      appendText(desc.description);
      result.push(
        `on(request: '${short}', handler: (params: ${title}Params) => Promise<${title}Result | Error>): () => void;`,
      );
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const args = desc.properties?.arguments ? desc.properties.arguments.$ref! : '#/definitions/';
      stubs.push({
        type: 'params',
        name: `${title}Params`,
        value: defs[definition(args)] || { properties: {} },
      });
      stubs.push({
        type: 'result',
        name: `${title}Result`,
        value: defs[`${name.substring(0, name.length - 'Request'.length)}Response`],
      });

      appendText(desc.description);
      result.push(`${short}Request(params: ${title}Params): Promise<${title}Result>;`);
    }
  }
  result.push(`}`);

  // ============================ TEST API ==============================

  interfaceSeparator();

  result.push(`export interface TestApi {`);
  for (const name in defs) {
    const def = defs[name];
    if (!def.allOf) {
      continue;
    }

    const ref = def.allOf.find(hasRef);
    const desc = def.allOf.find(parent => !hasRef(parent));
    if (!ref || !desc) {
      continue;
    }

    if (ref['$ref'] === '#/definitions/Event') {
      apiSeparator();
      appendText(desc.description);
      result.push(
        `on(request: '${
          desc.properties!.event.enum![0]
        }', handler: (params: ${name}Params) => void): void;`,
      );
      result.push(
        `off(request: '${
          desc.properties!.event.enum![0]
        }', handler: (params: ${name}Params) => void): void;`,
      );
      result.push(
        `once(request: '${
          desc.properties!.event.enum![0]
        }', filter?: (event: ${name}Params) => boolean): Promise<${name}Params>;`,
      );
    }

    if (ref['$ref'] === '#/definitions/Request') {
      const short = desc.properties!.command.enum![0];
      const title = toTitleCase(String(short));
      apiSeparator();
      appendText(desc.description);
      result.push(`${short}(params: ${title}Params): Promise<${title}Result>;`);
    }
  }
  result.push(`}`);

  // ============================ TYPES ==============================

  stubs.sort((a, b) => (a.name < b.name ? -1 : 1));
  for (const type of stubs) {
    interfaceSeparator();
    result.push(`export interface ${type.name} {`);
    if (type.type === 'result') {
      const desc = type.value.allOf!.find(parent => !parent['$ref'])!;
      type.value = desc.properties ? desc.properties.body : { properties: {} };
      while (type.value['$ref']) type.value = defs[definition(type.value['$ref'])];
    }
    appendProps(type.value.properties!, type.value.required);
    result.push(`}`);
  }

  while (types.length) {
    const type = types.pop()!;
    const def = defs[type];
    interfaceSeparator();
    appendText(def.description);
    if (def.type && def.type !== 'object') {
      result.push(`export type ${type} = ${def.type};`);
    } else {
      result.push(`export interface ${type} ${def.allOf ? getExtends(def) : ''} {`);

      if (def.allOf) {
        // def extends some other interface(s)
        const ownDescription = def.allOf.find(parent => !hasRef(parent))!;
        appendProps(ownDescription.properties!, ownDescription.required);
      } else {
        appendProps(def.properties!, def.required);
      }
      result.push(`}`);
    }
  }

  result.push(`}`);
  result.push(``);
  result.push(`export default Dap;`);
  result.push(``);

  writeCodeToFile(result.join('\n'), 'src/dap/api.d.ts');

  function isRequest(definition: JSONSchema4) {
    const ref = (definition.allOf || []).find(hasRef);
    return ref?.$ref === '#/definitions/Request';
  }

  function generateTelemetryClassifications(definitions: { [k: string]: JSONSchema4 }) {
    const definitionNames = Object.keys(defs);
    const requestNames = definitionNames.filter(name => isRequest(definitions[name]));

    const propertiesClassifications = requestNames.map(requestName => {
      const noPostfixAndLowercase = requestName.replace(/Request$/, '').toLowerCase();
      return `"${noPostfixAndLowercase}": { classification: 'SystemMetaData'; purpose: 'PerformanceAndHealth' },
      "!${noPostfixAndLowercase}.errors": { classification: 'CallstackOrException'; purpose: 'PerformanceAndHealth' },`;
    });

    const interfaceCode = `${autoGeneratedFileHeader('generateCdp.js')}
    interface IDAPOperationClassification {
      ${propertiesClassifications.join('\n')}
    }
    `;
    writeCodeToFile(interfaceCode, 'src/dap/telemetryClassification.d.ts', { printWidth: 150 });
  }

  generateTelemetryClassifications(defs);
}

generate().catch(console.error);
